#!/usr/bin/env python

"""
autosig.py

Generates the System Implementation Guide.

Copyright (c) 2014  Nexenta Systems
William Kettler <william.kettler@nexenta.com>
Pete Hartman <pete.hartman@nexenta.com>
"""

import os
import sys
import subprocess
import signal
import getopt
import simplejson
import time

# Define globals for convenience and to avoid complex passing
sig_version = "0.8"
collector = []
sig = None
global_ignore = False
partner_node = None
this_node = None


def usage():
    """
    Print usage.

    Inputs:
        None
    Outputs:
        None
    """
    cmd = sys.argv[0]

    print "%s [-h] [-c CONFIG] [-C COLLECTORDIR] [-i]" % cmd
    print ""
    print "Nexenta Auto-SIG"
    print ""
    print "Arguments:"
    print ""
    print "    -h, --help           print usage"
    print "    -c, --config         config file"
    print "    -C, --collector      collector directory"
    print "    -i, --ignore         ignore errors"


class Timeout(Exception):
    pass


class Execute(Exception):
    pass


def alarm_handler(signum, frame):
    raise Timeout


def execute(cmd, timeout=None):
    """
    Execute a command in the default shell. If a timeout is defined the command
    will be killed if the timeout is exceeded.

    Inputs:
        cmd     (str): Command to execute
        timeout (int): Command timeout in seconds
    Outputs:
        retcode  (int): Return code
        output  (list): STDOUT/STDERR
    """
    # Define the timeout signal
    if timeout:
        signal.signal(signal.SIGALRM, alarm_handler)
        signal.alarm(timeout)

    try:
        # Execute the command and wait for the subprocess to terminate
        # STDERR is redirected to STDOUT
        phandle = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)

        # Read the stdout/sterr buffers and retcode
        stdout, stderr = phandle.communicate()
        retcode = phandle.returncode
    except Timeout, t:
        # Kill the running process
        phandle.kill()
        raise Timeout("command timeout of %ds exceeded" % timeout)
    except Exception, err:
        raise Execute(err)
    else:
        # Possible race condition where alarm isn't disabled in time
        signal.alarm(0)

    # stdout may be None and we need to acct for it
    if stdout and stdout is not None:
        output = stdout.strip()
    else:
        output = None

    return retcode, output


def execute_collector(location, bundle, ignore, timeout=None):
    """
    Read data from collector as defined in the config file and write it to
    the SIG document.

    Inputs:
        location (str): Relative path to collector file to read
        bundle   (str): Absolute path to collector bundle
        ignore  (bool): Ignore return code
        timeout  (int): Command timeout in seconds
    Outputs:
        None
    """
    try:
        retcode, output = execute("cat %s/%s" % (bundle, location),
                                  timeout=timeout)
    except Exception, err:
        log("ERROR", "could not read file \"%s/%s\"" % (bundle, location))
        log("ERROR", str(err))
        if not ignore:
            sys.exit(1)

    # Check the command return code
    if retcode:
        log("ERROR", "collector read failed \"%s/%s\"" % (bundle, location))
        log("ERROR", output)
        if not ignore:
            log("INFO", "The '-i' option can be used to ignore errors")
            sys.exit(1)

    sig.print_paragraph("%s" % "_".join(bundle.split("_")[1:-1]).upper())
    sig.print_paragraph(output)


def execute_cmd(cmd, ignore, timeout=None):
    """
    Execute a command as defined in the config file and write it to the SIG
    document.

    Inputs:
        cmd     (str): Command to execute
        ignore (bool): Ignore return code
        timeout (int): Command timeout in seconds
    Outputs:
        None
    """
    try:
        retcode, output = execute(cmd, timeout=timeout)
    except Exception, err:
        log("ERROR", "command execution failed \"%s\"" % cmd)
        log("ERROR", str(err))
        if not ignore:
            sys.exit(1)

    # Check the command return code
    if retcode:
        log("ERROR", "command execution failed \"%s\"" % cmd)
        log("ERROR", output)
        if not ignore:
            log("INFO", "The '-i' option can be used to ignore errors")
            sys.exit(1)

    sig.print_paragraph("%s" % this_node.upper())
    sig.print_paragraph(output)


def execute_nmc(cmd, ignore, timeout=None):
    """
    Execute an NMC command as defined in the config file and write it to the
    SIG document.

    Inputs:
        cmd     (str): NMC command to execute
        ignore (bool): Ignore return code
        timeout (int): Command timeout in seconds
    Outputs:
        None
    """
    nmc = "nmc -c \"%s\"" % cmd
    try:
        retcode, output = execute(nmc, timeout=timeout)
    except Exception, err:
        log("ERROR", "NMC command execution failed \"%s\"" % cmd)
        log("ERROR", str(err))
        if not ignore:
            sys.exit(1)

    # Check the command return code
    if retcode:
        log("ERROR", "NMC command execution failed \"%s\"" % cmd)
        log("ERROR", output)
        if not ignore:
            log("INFO", "The '-i' option can be used to ignore errors")
            sys.exit(1)

    sig.print_paragraph("%s" % this_node.upper())
    sig.print_paragraph(output)


def ssh(cmd, host, ignore, timeout=None):
    """
    Execute a command on a remote host as defined in the config file and write
    it to the SIG document.

    Inputs:
        cmd     (str): Command to execute
        host    (str): Remote host
        ignore (bool): Ignore return code
        timeout (int): Command timeout in seconds
    Output:
        None
    """
    ssh_cmd = "ssh %s \"%s\"" % (host, cmd)
    try:
        retcode, output = execute(ssh_cmd, timeout)
    except Exception, err:
        log("ERROR", "SSH command execution failed \"%s\"" % ssh_cmd)
        log("ERROR", str(err))
        if not ignore:
            sys.exit(1)

    # Check the command return code
    if retcode:
        log("ERROR", "SSH command execution failed \"%s\"" % ssh_cmd)
        log("ERROR", output)
        if not ignore:
            log("INFO", "The '-i' option can be used to ignore errors")
            sys.exit(1)

    sig.print_paragraph("%s" % partner_node.upper())
    sig.print_paragraph(output)


def ssh_nmc(cmd, host, ignore, timeout=None):
    """
    Execute an NMC command on a remote host as defined in the config file
    and write it to the SIG document.

    Inputs:
        cmd     (str): NMC command to execute
        host    (str): Remote host
        ignore (bool): Ignore return code
        timeout (int): Command timeout in seconds
    Outputs:
        None
    """
    nmc = "nmc -c \\\"%s\\\"" % cmd
    ssh_nmc = "ssh %s \"%s\"" % (host, nmc)
    try:
        retcode, output = execute(ssh_nmc, timeout)
    except Exception, err:
        log("ERROR", "SSH NMC command execution failed \"%s\"" % ssh_nmc)
        log("ERROR", str(err))
        if not ignore:
            sys.exit(1)

    # Check the command return code
    if retcode:
        log("ERROR", "SSH NMC command execution failed \"%s\"" % ssh_nmc)
        log("ERROR", output)
        if not ignore:
            log("INFO", "The '-i' option can be used to ignore errors")
            sys.exit(1)

    sig.print_paragraph("%s" % partner_node.upper())
    sig.print_paragraph(output)


def log(severity, message):
    """
    Log a message to stdout.

    Inputs:
        severity (str): Severity string
        message  (str): Log message
    Outputs:
        None
    """
    date = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))
    print " %s [%s] %s" % (date, severity, message)


class Document:

    def __init__(self, f, stdout=False):
        self.stdout = stdout
        self.fh = open(f, 'w')

    def _write(self, s):
        """
        Wrapper function for the write method.

        Inputs:
            s (str): String
        Output:
            None
        """
        self.fh.write(s)
        self.fh.flush()

        # Write to stdout if defined
        if self.stdout:
            sys.stdout.write(s)
            sys.stdout.flush()

    def print_title(self, s):
        """
        Format and print title.
        e.g.
        =====
        TITLE
        =====

        Inputs:
            s (str): Title
        Outputs:
            None
        """
        self._write('\n')
        self._write('%s\n' % ('=' * len(s)))
        self._write('%s\n' % s.upper())
        self._write('%s\n' % ('=' * len(s)))
        self._write('\n')

    def print_section(self, s):
        """
        Format and print section title.
        e.g.
        Section
        -------

        Inputs:
            s (str): Section title
        Outputs:
            None
        """
        self._write('\n')
        self._write('%s\n' % s)
        self._write('%s\n' % ('-' * len(s)))
        self._write('\n')

    def print_sub_section(self, s, level=0):
        """
        Format and print sub-section title.
        e.g.
        [-]+ Sub-section

        Inputs:
            s (str): Sub-section title
            level (int): Sub-section level`
        Outputs:
            None
        """
        self._write('\n')
        self._write('%s+ %s\n' % ('-' * level, s))
        self._write('\n')

    def print_string(self, s):
        """
        Format and print a string.

        Inputs:
            s (str): String
        Outputs:
            None
        """
        self._write('%s\n' % s)

    def print_paragraph(self, p):
        """
        Format and print a paragraph.

        Inputs:
            p (str): Paragraph
        Outputs:
            None
        """
        self._write('%s\n\n' % p)

    def print_newline(self):
        """
        Print newline.

        Inputs:
            None
        Outputs:
            None
        """
        self._write('\n')

    def __exit__(self):
        # Close file
        if fh is not sys.stdout:
            self.fh.close()


def hostname():
    """
    Return the system hostname.

    Inputs:
        None
    Outputs:
        hostname (str): System hostname
    """
    if collector:
        retcode, hostname = execute("cat %s/network/nodename" % collector)
    else:
        retcode, hostname = execute("hostname")
    if retcode:
        log("ERROR", "failed to get system hostname")
        log("ERROR", output)
        sys.exit(1)

    return hostname.strip()


def rsf_partner():
    """
    Return cluster partner hostname.

    Inputs:
        None
    Outputs:
        partner (str): Partner hostname
    """
    rsfcli = "/opt/HAC/RSF-1/bin/rsfcli -i0"
    hosts = []
    partner = None
    name = None

    # First try to determine if the cluster is configured.
    # 4.x makes determination tricky because the service is installed
    # and running by default.

    # Make sure services are running
    try:
        retcode, output = execute("%s isrunning" % rsfcli)
    except Exception, err:
        log("ERROR", "unable to determine RSF service state")
        log("ERROR", output)
        sys.exit(1)

    # Non-zero return code means service is not running
    if retcode:
        log("INFO", "RSF service is not running")
        return partner

    log("INFO", "RSF service is running")

    # Parse the RSF status
    retcode, output = execute("/opt/HAC/RSF-1/bin/rsfcli status")
    for l in output.splitlines():
        if l.startswith("Contacted"):
            name = l.split()[4].rstrip(",").strip("\"")
        elif l.startswith("Host"):
            hosts.append(l.split()[1].strip())

    # Check for default 4.x configuration
    if name == "Ready_For_Cluster_Configuration":
        log("INFO", "Cluster is not configured")
        return partner

    log("INFO", "RSF cluster is configured")

    # Determine which clustered host is the partner
    for h in hosts:
        if h != this_node:
            partner = h
            log("INFO", "%s is partner node" % partner)
            break

    return partner


def sections(section, level):
    """
    Iterate over a section.

    Inputs:
        section
        level
    Outputs:
        None
    """
    # Valid keys
    valid = ["_version", "title", "enabled", "paragraph", "cmd", "nmc",
             "sections", "collector", "ignore"]
    # Required keys
    required = ["title", "enabled"]

    # Iterate over each sub-section
    for subsection in section:
        # Verify required keys are present
        for key in required:
            if key not in subsection:
                log("ERROR", "Required key \"%s\" missing" % key)
                sys.exit(1)

        # Verify there are no unsupported keys present
        for key in subsection:
            if key not in valid:
                log("ERROR", "Invalid key \"%s\"" % key)
                sys.exit(1)

        # Continue if the section is disabled
        if not subsection["enabled"]:
            continue

        # Handle version number
        # Should only be present in root of JSON file
        if "_version" in subsection:
            conf_version = subsection["_version"]
            log("INFO", "Configuration v%s" % conf_version)
            sig.print_string("Configuration v%s" % conf_version)

        # Handle title
        title = subsection["title"]
        log("INFO", "Section \"%s\"" % title)
        if level == 0:
            sig.print_title(title)
        elif level == 1:
            sig.print_section(title)
        else:
            sig.print_sub_section(title, level-2)

        # Handle paragraph
        if "paragraph" in subsection:
            paragraph = subsection["paragraph"]
            if paragraph is not None:
                sig.print_paragraph(paragraph)

        # Check if ignore is defined
        if "ignore" in subsection:
            log("INFO", "Ignoring exit code")
            ignore = subsection["ignore"] or global_ignore
        else:
            ignore = global_ignore

        # Handle collector fields: alternative to both cmd and nmc
        if len(collector) != 0:
            if "collector" in subsection:
                location = subsection["collector"]

                if location is not None:
                    sig.print_paragraph("[%s]" % location)
                    for c in collector:
                        execute_collector(location, c, ignore)
            else:
                log("WARN", "Collector generation specified but section "
                            "\"%s\" has no collector subsection" % title)
        else:
            # Handle command
            if "cmd" in subsection:
                cmd = subsection["cmd"]

                if cmd is not None:
                    sig.print_paragraph("[%s]" % cmd)
                    # Execute on this node
                    execute_cmd(cmd, ignore)
                    # Execute on remote node
                    if partner_node is not None:
                        ssh(cmd, partner_node, ignore)

            # Handle nmc
            if "nmc" in subsection:
                nmc = subsection["nmc"]

                if nmc is not None:
                    sig.print_paragraph("[%s]" % nmc)
                    # Execute on this node
                    execute_nmc(nmc, ignore)
                    # Execute on the remote node
                    if partner_node is not None:
                        ssh_nmc(nmc, partner_node, ignore)

        # Handle sections
        if "sections" in subsection:
            sections(subsection["sections"], level + 1)


def main():
    # Initialize variables
    global sig
    global collector
    global global_ignore
    global partner_node
    global this_node
    config = "autosig.conf"

    # Define the command line arguments
    try:
        opts, args = getopt.getopt(sys.argv[1:], ":hc:C:i",
                                   ["help", "config=", "collector=", "ignore"])
    except getopt.GetoptError, err:
        log("ERROR", str(err))
        usage()
        sys.exit(2)

    # Parse the command line arguments
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-c", "--config"):
            config = a
        elif o in ("-C", "--collector"):
            collector.append(a)
        elif o in ("-i", "--ignore"):
            global_ignore = True

    # Open the configuration file
    try:
        fh = open(config)
    except Exception, err:
        log("ERROR", "Cannot open the config file")
        log("ERROR", str(err))
        sys.exit(1)

    # Parse the configuration file
    try:
        outline = simplejson.load(fh, encoding=None, cls=None,
                                  object_hook=None)
    except Exception, err:
        log("ERROR", "Cannot parse the config file")
        log("ERROR", str(err))
        sys.exit(1)
    finally:
        fh.close()

    # Test existence to prevent confusing errors downstream
    if len(collector) != 0:
        for c in collector:
            if not os.path.isdir(c):
                log("ERROR", "No collector directory '%s'" % collector)
                sys.exit(1)

    # Get hostnames initialize variables
    if len(collector) == 0:
        this_node = hostname()
        partner_node = rsf_partner()

    # Open the output file
    f = "nexenta-autosig.txt"
    sig = Document(f)
    log("INFO", "Writing output to %s" % f)

    # Write the version number
    log("INFO", "Auto-SIG v%s" % sig_version)
    sig.print_string("Auto-SIG v%s" % sig_version)

    # Write collector bundle names
    if len(collector) != 0:
        sig.print_newline()
        for c in collector:
            sig.print_string(c)

    # Iterate over the document sections
    level = 0
    sections([outline], level)

    log("INFO", "Complete!")


if __name__ == "__main__":
    main()
